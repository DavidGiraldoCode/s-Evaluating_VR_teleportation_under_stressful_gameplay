# Session notes

Here is the revised version of the README with typos and clarity improved:

---

## Session 2024-11-05: Adding Graph and Distances

- **Objective:** Implement the algorithms to determine which platform to teleport to.
- Create the cycle graph data structure.
- Create the list of distances `{ -3, -2, -1, 1, 2, 3 }`, shuffle it, and store the values in a stack.
- Use the graph to query the color that will be prompted to the user.
- Pop distances from the stack to determine the color.

The graph’s purpose is to represent colors that we can query using abstract distances or steps when the player is prompted to move to a new location. This is independent of real-world distances. Each vertex/node in the graph corresponds to a platform color. The only relationship between the graph and the physical platform layout is the color (number) of the current platform the player is standing on, which allows us to determine the starting node for movement.

Given the hexagonal layout of the six platforms (one at each vertex), the order of platforms should match the graph nodes. Thus, the adjacency list in the graph reflects how the platforms are distributed relative to each other in worl space.

```bash
Platform -> red(0), blue(1), green(2), ...
Graph    -> { 0, 1, 2, ... }
```

Since the graph does not exist as a GameObject in the scene, it does not need a visual representation or to be affected by transformations. Therefore, it can be implemented as a `ScriptableObject`.

### Generating the coordinates

The coordinate is generated by creating a list with `{ -3, -2, -1, 1, 2, 3 }` and then multiplying that list by the number of times one might want all the platforms to be equally visited. So a input of 5 creates 30 coordinates that will translate on 30 colors. Bear in mind that the coordinates need to be translated by the graph as they depend on the player's starting position. This allows for the player to be randomly relocated to any platform without the need to create the coordinates list again.

The coordinates are handled via a native C# class in Utilities and implement Fisher-Yates shuffle.

### ⚠️ Update!

- Considering the range of the Graph `[0,5]` and the `enum` that holds the colors (`taskColors`). I made a change in the structure so the casting of values matches.

**Old**

```C#
enum taskColors
{
    NONE,
    RED,
    GREEN
}
```

**New**

```C#
enum taskColors
{
    RED,
    GREEN,
    NONE,
}
```
- The Graph might be better off as a Native class inside Utilities as well

### Observations
- I populate the `public taskColors[] HardCodedTrialSequence;` that was filled up in the editor on the GameState SO. However, the locations do not seem to be correct. Review this. 
- I created a second version of the graph class using the `Utilities` namespace. Since it does not use anything from Unity, and only GameState uses its methods.


## Session 2024-11-21: Incorporating the graph with the platforms

- **Objective:** Connect the graph system with platform and update next target
- [ ] Start on red platform
- [ ] Create the list of distances at the begning of each task, practice and trial.
- [ ] Update the target platform given the graph
- [ ] Remove the colors from the stack.